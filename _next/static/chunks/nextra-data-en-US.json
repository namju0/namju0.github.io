{"/posts/ffmpeg-video-editing-guide":{"title":"ffmpeg로 동영상 편집하기 - 포맷 변환부터 구간 자르기까지","data":{"":"ffmpeg는 무료이면서도 강력한 동영상 편집 도구로 널리 사용되고 있습니다. 이번 포스팅에서는 ffmpeg를 사용하여 동영상 포맷을 변경하거나 화질을 조정하고, 화면을 크롭하거나 구간을 자르는 등 기본적인 작업을 수행해 봅니다. 여러 영상을 합치는 방법과 동영상에서 소리만 추출하는 만드는 방법도 함께 알아보겠습니다.","1-동영상-포맷-변경#1. 동영상 포맷 변경":"동영상 파일의 포맷을 변경하는 방법은 매우 간단합니다. ffmpeg의 기본 명령어를 사용해 입력 파일의 확장자와 출력 파일의 확장자를 지정해주기만 하면 됩니다.\nffmpeg -i input.mp4 output.avi\n위 명령어는 input.mp4를 AVI 포맷으로 변환하여 output.avi로 저장합니다.","2-포맷은-유지하면서-화질-변경#2. 포맷은 유지하면서 화질 변경":"동영상 화질을 낮추거나 높이기 위해 비트레이트를 조정할 수 있습니다. 비트레이트는 높을수록 화질이 좋아지지만 그만큼 파일 크기 커진다는 것을 참고해 주세요.\nffmpeg -i input.mp4 -b:v 1000k output.mp4\n이 명령어는 비트레이트를 1000kbps로 설정하여 output.mp4로 저장합니다.","3-동영상-화면-자르기크롭-crop#3. 동영상 화면 자르기(크롭, crop)":"영상의 특정 부분만 잘라내고 싶을 때는 -vf crop 필터를 사용합니다. 다음 명령어는 640x480 크기로 화면을 잘라냅니다.\nffmpeg -i input.mp4 -vf \"crop=640:480:100:50\" output.mp4\n여기에서는 왼쪽으로부터 100px, 위로부터 50px을 시작점으로 640x480 크기를 잘라내어 비디오를 만듭니다.","4-구간-자르기컷-편집#4. 구간 자르기(컷 편집)":"동영상의 특정 구간만 잘라내는 방법은 -ss(시작 시간)과 -to(끝 시간) 옵션을 사용합니다.\nffmpeg -i input.mp4 -ss 00:01:00 -to 00:02:00 -c copy output.mp4\n이 명령어는 1분에서 2분 사이의 구간만 잘라 output.mp4로 저장합니다.","5-여러-영상-합치기#5. 여러 영상 합치기":"여러 동영상을 하나로 이어 붙여 합칠 때는 파일 목록을 .txt 파일로 만들어 이를 기반으로 처리합니다.\n파일 목록을 만드세요:\nfile 'part1.mp4'\nfile 'part2.mp4'\nfile 'part3.mp4'\n이어서 다음과 같이 실행하세요:\nffmpeg -f concat -safe 0 -i file_list.txt -c copy output.mp4\n이렇게 하면 파일 목록에 나열된 동영상을 순서대로 이어 붙어 합쳐진 output.mp4이 생성됩니다.","6-동영상에서-소리만-추출해-mp3-만들기#6. 동영상에서 소리만 추출해 MP3 만들기":"동영상에서 오디오만 추출하려면 -vn(비디오 제외) 옵션을 사용하여 비디오를 제외하고 오디오만 남깁니다.\nffmpeg -i input.mp4 -vn -acodec mp3 output.mp3\n이렇게 함으로써 동영상에서 소리만 추출하여 MP3 파일로 만들 수 있습니다.ffmpeg는 무료이지만 매우 강력한 동영상 편집 도구로, 다양한 형식의 동영상 파일을 쉽게 변환하거나 편집할 수 있습니다. ffmpeg는 훨씬 많은 복잡한 기능을 갖고 있지만 우리가 자주 사용하게 되는 것만 일부 소개해 보았습니다. ffmpeg는 커맨드라인 기반(CLI)이라 사용이 다소 어려울 수 있지만 필요한 이용법만 기억했다 사용하면 GUI 기반 툴보다 오히려 편리할 수 있습니다."}},"/posts/how-to-deploy-nextjs-blog-on-github-pages":{"title":"Next.js 블로그를 GitHub Pages에 배포하는 방법 (Blog Boilerplate 사용)","data":{"nextjs-블로그를-github-pages에-배포하는-방법-blog-boilerplate-사용#Next.js 블로그를 GitHub Pages에 배포하는 방법 (Blog Boilerplate 사용)":"Next.js Blog Boilerplate를 사용해 생성한 정적 블로그를 GitHub Pages에 배포하는 과정입니다. React 등 기타 요소를 깊숙히 다루지 않고도 간단하고 깔끔한 정적 블로그를 간편하게 제작할 수 있는 방법을 소개합니다.","1-nextjs-blog-boilerplate-클론#1. Next.js Blog Boilerplate 클론":"","1-1-프로젝트-클론#1-1. 프로젝트 클론":"먼저 Next.js Blog Boilerplate를 로컬에 클론합니다:\ngit clone <https://github.com/vercel/next.js.git>\ncd next.js/examples/blog","1-2-패키지-설치#1-2. 패키지 설치":"클론한 디렉토리에서 패키지를 설치합니다:\nnpm install","1-3-로컬-서버-실행#1-3. 로컬 서버 실행":"다음 명령어로 로컬 개발 서버를 실행합니다:\nnpm run dev\n브라우저에서 http://localhost:3000에 접속해 블로그가 정상적으로 보이는지 확인하세요.","2-git-리포지토리-설정#2. Git 리포지토리 설정":"이제 프로젝트를 GitHub 리포지토리에 배포할 수 있도록 Git 리포지토리를 설정합니다.","2-1-git-리포지토리-생성#2-1. Git 리포지토리 생성":"GitHub에서 <your-github-username>.github.io 라는 리포지토리를 생성합니다. 생성 시 ‘Initialize this repository with:’ 설정에서 ‘Add a README file’을 체크하여 리포지토리 생성과 동시에 초기화를 합니다.","2-2-github-리포지토리-연결#2-2. GitHub 리포지토리 연결":"로컬 프로젝트는 현재 https://github.com/vercel/next.js.git 와 연결되어 있습니다. 로컬 프로젝트를 새로 생성한 GitHub 리포지토리와 연결합니다:\ngit remote set-url origin https://github.com/<your-github-username>/<your-github-username>.github.io.git","3-github-pages-배포-준비#3. GitHub Pages 배포 준비":"GitHub Pages에 블로그를 배포하기 위한 몇 가지 추가 설정이 필요합니다.","3-1-gh-pages-패키지-설치#3-1. gh-pages 패키지 설치":"GitHub Pages에 배포하려면 gh-pages 패키지를 설치해야 합니다:\nnpm install gh-pages --save-dev","3-2-nextconfigjs-설정#3-2. next.config.js 설정":"GitHub Pages에서는 리포지토리 이름을 기반으로 경로를 설정해야 합니다. 프로젝트 루트에 있는**next.config.js** 파일을 열어, nextConfig에 다음 내용을 추가 작성합니다:\nconst nextConfig = {\n  // ... 전략 ...\n  output: 'export',\n  images: {\n    unoptimized: true\n  }\n  // ... 후략 ...\n};","3-3-packagejson-수정#3-3. package.json 수정":"package.json 파일에 배포를 위한 스크립트를 추가합니다. scripts 섹션을 아래처럼 작성하세요:\n{\n  \"scripts\": {\n    \"dev\": \"next\",\n    \"build\": \"node ./scripts/gen-rss.js && next build\",\n    \"start\": \"next start\",\n    \"deploy\": \"touch out/.nojekyll && gh-pages -d out --dotfiles\"\n  }\n}\n이 스크립트는 npm run build로 out 디렉토리를 생성하고 npm run deploy로 그 디렉토리를 GitHub 리포지토리에 배포할 수 있게 해 줍니다.","4-github-pages-설정-및-배포#4. GitHub Pages 설정 및 배포":"","4-1-github-pages-설정#4-1. GitHub Pages 설정":"GitHub 리포지토리의 Settings > Pages 섹션으로 이동합니다. 배포할 브랜치를 gh-pages로 설정하고, 저장합니다. 그러면 GitHub Pages에서 블로그를 배포할 준비가 완료됩니다.","4-2-블로그-배포#4-2. 블로그 배포":"이제 블로그를 빌드합니다.\nnpm run build\n이 명령어를 실행하면 블로그가 out 디렉토리에 생성됩니다.이를 GitHub Pages에 배포합니다:\nnpm run deploy\n이 명령어를 실행하면 블로그가 gh-pages 브랜치에 푸시되고 GitHub Pages에 배포됩니다.","4-3-배포된-블로그-확인#4-3. 배포된 블로그 확인":"배포가 완료되면 브라우저에서 https://<your-github-username>.github.io로 접속하여 블로그가 정상적으로 배포되었는지 확인합니다.","5-새로운-포스트-작성-markdown-사용#5. 새로운 포스트 작성 (Markdown 사용)":"이제 블로그에 새로운 포스트를 추가하는 방법을 설명합니다. Markdown 파일을 사용해 쉽게 포스트를 작성할 수 있습니다.","5-1-markdown-파일-생성#5-1. Markdown 파일 생성":"pages/posts 폴더에 새로운 Markdown 파일을 추가합니다. 예를 들어, test.md 파일을 다음과 같이 작성할 수 있습니다:\n---\ntitle: Test Article\ndate: 2024/9/20\ndescription: It is a test article.\ntag: test\nauthor: You\n---\nIt is a test article.\nIt is only for test purpose.","5-2-포스트-빌드-및-배포#5-2. 포스트 빌드 및 배포":"Markdown 파일을 추가한 후, 다시 블로그를 빌드하고 배포합니다:\nnpm run build\nnpm run deploy\n이제 새로운 포스트가 블로그에 추가된 것을 확인할 수 있습니다.","6-사이트맵#6. 사이트맵":"npm run build 수행 시마다 정적 사이트맵 파일(sitemap.xml)을 갱신 및 생성하게 하는 방법입니다.","6-1-next-sitemap--패키지-설치#6-1. next-sitemap  패키지 설치":"npm install next-sitemap","6-2-next-sitemapconfigjs-설정#6-2. next-sitemap.config.js 설정":"프로젝트 루트에 next-sitemap.config.js 파일을 다음과 같이 생성합니다:\n/** @type {import('next-sitemap').IConfig} */\nmodule.exports = {\n  siteUrl: process.env.SITE_URL || 'https://<your-github-username>.github.io',\n  generateRobotsTxt: true,\n  generateIndexSitemap: false,\n}","6-3-packagejson-수정#6-3. package.json 수정":"package.json 파일에 사이트맵 생성을 위한 스크립트를 추가합니다. scripts 섹션에  postbuild를 아래처럼 추가하세요:\n{\n  \"scripts\": {\n    // ... 전략 ...\n    \"postbuild\": \"next-sitemap\",\n    // ... 후략 ...\n  }\n}","결론#결론":"Next.js Blog Boilerplate를 사용해 GitHub Pages에 블로그를 배포하는 방법을 알아보았습니다. Boilerplate의 적용, GitHub 리포지토리 생성 및 Git 설정, Next.js 설정, Markdown 포스트 작성, 사이트맵 생성에 이르는 방법을 Step-by-Step 설명하였고, 차근차근 따라하면 손쉽게 정적 블로그를 만들어 볼 수 있게 내용을 구성해 보았습니다."}},"/posts/pd-crosstab-tutorial-with-example":{"title":"pd.crosstab을 활용한 데이터 분석(신용등급 전이행렬 예제)","data":{"":"데이터 분석 중 변수들 간 관계를 분석해야 할 때가 많습니다. 범주형(categorical) 데이터의 교차 빈도를 요약하는 일이 대표적입니다. 판다스 라이브러리의 pd.crosstab 를 활용하면 범주형 데이터의 교차 빈도를 요약한 교차표를 쉽게 만들 수 있습니다.","1-pdcrosstab이란#1. pd.crosstab이란?":"pd.crosstab은 행과 열의 교차점을 기준으로 데이터를 요약, 교차 빈도를 집계하는 함수입니다. 두 개의 범주형 데이터를 비교할 때 유용하며, 범주형 데이터 간의 빈도수(데이터 값 쌍별 빈도수)를 빠르게 파악할 수 있습니다.","2-사용법#2. 사용법":"pd.crosstab의 기본 구문은 아래와 같습니다.\npd.crosstab(index, columns, values=None, aggfunc=None, margins=False, normalize=False)\nindex: 행에 들어갈 데이터\ncolumns: 열에 들어갈 데이터\nnormalize: 비율로 계산할지 여부 (기본값은 False)","3-신용등급-전이행렬-예제#3. 신용등급 전이행렬 예제":"신용등급 전이행렬을 pd.crosstab으로 만드는 간단한 예제입니다. 이전 신용등급 목록과 이후 신용등급 목록이 주어졌을 때, 이를 집계하여 신용등급 쌍 간 전이 확률(또는 빈도)을 계산하는 데 쓰입니다.\nimport pandas as pd\n# 신용등급 데이터 (가상 데이터)\ninitial_ratings = ['AAA', 'AAA', 'AA', 'A', 'BBB', 'BB', 'B', 'B', 'CCC', 'AA', 'A', 'BBB', 'A', 'BB', 'CCC']\nfinal_ratings = ['AA', 'AAA', 'A', 'BBB', 'BBB', 'B', 'BB', 'CCC', 'CCC', 'A', 'BBB', 'BB', 'AA', 'CCC', 'B']\n# Crosstab으로 전이행렬 생성\ntransition_matrix = pd.crosstab(index=initial_ratings, columns=final_ratings, normalize='index')\n# 결과 출력\nprint(transition_matrix)","4-신용등급-전이행렬-예제-결과#4. 신용등급 전이행렬 예제 결과":"실행 결과, 다음과 같은 전이행렬이 출력됩니다.\ncol_0    A        AA  AAA    B   BB       BBB  CCC\nrow_0\nA      0.0  0.333333  0.0  0.0  0.0  0.666667  0.0\nAA     1.0  0.000000  0.0  0.0  0.0  0.000000  0.0\nAAA    0.0  0.500000  0.5  0.0  0.0  0.000000  0.0\nB      0.0  0.000000  0.0  0.0  0.5  0.000000  0.5\nBB     0.0  0.000000  0.0  0.5  0.0  0.000000  0.5\nBBB    0.0  0.000000  0.0  0.0  0.5  0.500000  0.0\nCCC    0.0  0.000000  0.0  0.5  0.0  0.000000  0.5\n각 신용등급에서 다른 등급으로 전이될 확률을 2차원 표(행렬) 형태로 보여줍니다. 예를 들어, AAA 등급에서 AA 등급으로 전이될 확률은 50%, A 등급에서 BBB 등급으로 전이될 확률은 약 66.67%입니다. 이와 같은 전이행렬을 통해 신용등급의 변동 패턴을 분석할 수 있습니다.","5-결론#5. 결론":"pd.crosstab은 간단하지만 강력한 데이터 요약 도구입니다. 범주형 데이터를 다룰 때 자주 쓰이며, 특히 교차 빈도를 측정하여 전이행렬 등으로 요약할 때 유용합니다. 여기서 예제로 든 신용등급 전이행렬 외에도 다양한 상황에서 활용할 수 있습니다."}},"/posts/vim-command-line-paste-guide":{"title":"Vim에서 클립보드 내용을 명령줄에 붙여넣는 방법","data":{"":"Vim을 사용할 때, 클립보드 내용을 명령줄에 붙여넣어야 할 상황이 자주 발생합니다. :w 로 파일을 저장할 때 정해진 경로에 파일을 생성하려면 경로를 클립보드에 복사해 붙여 넣어야 하는 일이 많습니다. 가령, :w C:\\Program Files (x86)\\...\\output.txt와 같은 명령을 명령줄에 입력해야 할 때를 떠올릴 수 있습니다.다음과 같이 하면 Vim 편집기의 내용을 복사(yank)하여 Vim 명령줄에 붙여넣을 수 있습니다. 이렇게 함으로써 복잡한 텍스트가 필요한 명령어를 편리하게 쓸 수 있습니다. 물론 Vim 외부의 텍스트를 명령줄에 바로 복사, 붙여넣기할 수는 없지만 외부 텍스트를 Vim 편집기에 한번 붙여 넣은 후 yank해 동일한 효과를 낼 수 있습니다.","방법#방법:":"텍스트를 먼저 복사(yank)합니다. 가령, yy로 원하는 부분을 행복사합니다.\n: 키를 눌러 명령 모드로 진입합니다.\nCtrl-R을 누른 후, \"을 입력하여 기본 레지스터의 내용을 붙여넣습니다.\n참고로 기본 레지스터(yy 로 yank 시 복사되는 곳)외 다른 Vim 레지스터에 대해서도 위 방법을 적용할 수 있습니다. 예를 들어, \"ayy 로 행복사를 레지스터 a에 하고 명령줄에서 Ctrl-R을 누른 후 \"  대신 a 를 입력하면 됩니다."}},"/posts/vim-diff-two-files-guide":{"title":"Vim에서 파일 비교하기(diffthis)","data":{"":"소스코드나 설정파일 등 텍스트 파일의 내용을 비교해야 하는 상황이 자주 발생합니다. 때로는 셋 이상의 여러 파일 간의 차이를 확인해야 할 때도 있습니다. 이때 Vim의 :diffthis 명령어를 유용하게 사용할 수 있습니다. 두 파일을 비교하는 기본적인 방법과, 세 개의 파일을 동시에 비교하는 방법을 소개합니다.","두-파일-비교#두 파일 비교":"Vim에서는 :diffthis 명령어를 통해 동시에 열려 있는(정확히는 같은 탭(tab)에 열려 있는) 창(window)에서 연 파일을 비교할 수 있습니다. Vim에서 여러 파일을 분할해 열어 놓은 후 각 분할(각 파일)에 대해 :diffthis를 실행하면 됩니다.(split, vsplit 으로 분할이 생길 때마다 창이 생긴다 보면 됨)","예제#예제":"Vim에서 첫 번째 파일을 엽니다:\nvim file1.txt\n두 번째 파일을 수직으로 분할하여 엽니다:\n:vsplit file2.txt\n각각의 창에서 :diffthis 명령어를 실행하여 diff 모드를 활성화합니다:\n:diffthis   \" 첫 번째 창에서 실행\nCtrl+W →    \" 두 번째 창으로 이동\n:diffthis   \" 두 번째 창에서 실행\n이렇게 하면 두 파일의 차이점이 각각의 창에 하이라이트되며, 추가되거나 삭제된 라인이 표시됩니다.","세-파일-비교또는-셋-이상#세 파일 비교(또는 셋 이상)":"세 개의 파일을 동시에 비교하고자 한다면, windo 명령어를 사용하여 각 창에 :diffthis 명령어를 한 번에 적용할 수 있습니다. 세 개 이상의 창을 열고 windo :diffthis를 실행하면, 열린 모든 창에 대해 :diffthis가 자동으로 적용됩니다.","예제-1#예제":"첫 번째 파일을 엽니다:\nvim file1.txt\n두 번째 파일을 수직 분할하여 엽니다:\n:vsplit file2.txt\n세 번째 파일을 수평 분할하여 엽니다:\n:split file3.txt\n모든 창에 대해 diff 모드를 적용하기 위해 다음 명령어를 실행합니다:\n:windo diffthis\n이렇게 하면 Vim에 열려 있는 모든 파일(같은 탭에 열린 윈도우들)의 차이점이 각각의 창에 하이라이트되며, 차이가 있는 부분이 표시됩니다.","세-파일-예시#세 파일 예시":"아래의 예시 파일들은 서로 다른 내용이 포함되어 있습니다:\nfile1.txt\nHello World!\nThis is a sample file.\nIt contains some text.\nfile2.txt\nHello World!\nThis is another file.\nIt contains some different text.\nfile3.txt\nHello World!\nThis is a third file.\nIt contains even more different text.\n위와 같은 파일을 열고 :windo diffthis 명령어를 실행하면, 세 파일의 차이점을 한눈에 볼 수 있습니다.","결론#결론":"Vim에서 :diffthis 명령어와 windo를 사용하면 두 개 또는 세 개 이상의 파일을 효율적으로 비교할 수 있습니다. 두 파일을 비교할 때는 각 창에서 개별적으로 :diffthis를 실행하고, 세 파일 이상을 비교할 때는 windo를 활용하여 한 번에 diff 모드를 활성화할 수 있습니다.(물론, 두 파일을 비교할 때도 :windo diffthis를 써도 됨)"}},"/":{"title":"About","data":{"":"Computer Science 학사 및 석사이며 현재 은행에 재직중입니다.은행 재직 중 Data Science 석사 학위를 추가로 취득하였으며 LLM의 응용에 관심이 많습니다.Ordinary user 관점에서의 생성형 AI(ChatGPT 등) prompting을 최근 공부하고 있습니다.Python, JavaScript를 활용한 구현을 즐기며,Vim, tmux 등 tool에도 흥미를 많이 느낍니다."}},"/posts":{"title":"Posts","data":{}},"/tags/[tag]":{"title":"Tagged Posts","data":{}}}