{"/posts/how-to-deploy-nextjs-blog-on-github-pages":{"title":"Next.js 블로그를 GitHub Pages에 배포하는 방법 (Blog Boilerplate 사용)","data":{"nextjs-블로그를-github-pages에-배포하는-방법-blog-boilerplate-사용#Next.js 블로그를 GitHub Pages에 배포하는 방법 (Blog Boilerplate 사용)":"Next.js Blog Boilerplate를 사용해 생성한 정적 블로그를 GitHub Pages에 배포하는 과정입니다. React 등 기타 요소를 깊숙히 다루지 않고도 간단하고 깔끔한 정적 블로그를 간편하게 제작할 수 있는 방법을 소개합니다.","1-nextjs-blog-boilerplate-클론#1. Next.js Blog Boilerplate 클론":"","1-1-프로젝트-클론#1-1. 프로젝트 클론":"먼저 Next.js Blog Boilerplate를 로컬에 클론합니다:\ngit clone <https://github.com/vercel/next.js.git>\ncd next.js/examples/blog","1-2-패키지-설치#1-2. 패키지 설치":"클론한 디렉토리에서 패키지를 설치합니다:\nnpm install","1-3-로컬-서버-실행#1-3. 로컬 서버 실행":"다음 명령어로 로컬 개발 서버를 실행합니다:\nnpm run dev\n브라우저에서 http://localhost:3000에 접속해 블로그가 정상적으로 보이는지 확인하세요.","2-git-리포지토리-설정#2. Git 리포지토리 설정":"이제 프로젝트를 GitHub 리포지토리에 배포할 수 있도록 Git 리포지토리를 설정합니다.","2-1-git-리포지토리-생성#2-1. Git 리포지토리 생성":"GitHub에서 <your-github-username>.github.io 라는 리포지토리를 생성합니다. 생성 시 ‘Initialize this repository with:’ 설정에서 ‘Add a README file’을 체크하여 리포지토리 생성과 동시에 초기화를 합니다.","2-2-github-리포지토리-연결#2-2. GitHub 리포지토리 연결":"로컬 프로젝트는 현재 https://github.com/vercel/next.js.git 와 연결되어 있습니다. 로컬 프로젝트를 새로 생성한 GitHub 리포지토리와 연결합니다:\ngit remote set-url origin https://github.com/<your-github-username>/<your-github-username>.github.io.git","3-github-pages-배포-준비#3. GitHub Pages 배포 준비":"GitHub Pages에 블로그를 배포하기 위한 몇 가지 추가 설정이 필요합니다.","3-1-gh-pages-패키지-설치#3-1. gh-pages 패키지 설치":"GitHub Pages에 배포하려면 gh-pages 패키지를 설치해야 합니다:\nnpm install gh-pages --save-dev","3-2-nextconfigjs-설정#3-2. next.config.js 설정":"GitHub Pages에서는 리포지토리 이름을 기반으로 경로를 설정해야 합니다. 프로젝트 루트에 있는**next.config.js** 파일을 열어, nextConfig에 다음 내용을 추가 작성합니다:\nconst nextConfig = {\n  // ... 전략 ...\n  output: 'export',\n  images: {\n    unoptimized: true\n  }\n  // ... 후략 ...\n};","3-3-packagejson-수정#3-3. package.json 수정":"package.json 파일에 배포를 위한 스크립트를 추가합니다. scripts 섹션을 아래처럼 작성하세요:\n{\n  \"scripts\": {\n    \"dev\": \"next\",\n    \"build\": \"node ./scripts/gen-rss.js && next build\",\n    \"start\": \"next start\",\n    \"deploy\": \"touch out/.nojekyll && gh-pages -d out --dotfiles\"\n  }\n}\n이 스크립트는 npm run build로 out 디렉토리를 생성하고 npm run deploy로 그 디렉토리를 GitHub 리포지토리에 배포할 수 있게 해 줍니다.","4-github-pages-설정-및-배포#4. GitHub Pages 설정 및 배포":"","4-1-github-pages-설정#4-1. GitHub Pages 설정":"GitHub 리포지토리의 Settings > Pages 섹션으로 이동합니다. 배포할 브랜치를 gh-pages로 설정하고, 저장합니다. 그러면 GitHub Pages에서 블로그를 배포할 준비가 완료됩니다.","4-2-블로그-배포#4-2. 블로그 배포":"이제 블로그를 빌드합니다.\nnpm run build\n이 명령어를 실행하면 블로그가 out 디렉토리에 생성됩니다.이를 GitHub Pages에 배포합니다:\nnpm run deploy\n이 명령어를 실행하면 블로그가 gh-pages 브랜치에 푸시되고 GitHub Pages에 배포됩니다.","4-3-배포된-블로그-확인#4-3. 배포된 블로그 확인":"배포가 완료되면 브라우저에서 https://<your-github-username>.github.io로 접속하여 블로그가 정상적으로 배포되었는지 확인합니다.","5-새로운-포스트-작성-markdown-사용#5. 새로운 포스트 작성 (Markdown 사용)":"이제 블로그에 새로운 포스트를 추가하는 방법을 설명합니다. Markdown 파일을 사용해 쉽게 포스트를 작성할 수 있습니다.","5-1-markdown-파일-생성#5-1. Markdown 파일 생성":"pages/posts 폴더에 새로운 Markdown 파일을 추가합니다. 예를 들어, test.md 파일을 다음과 같이 작성할 수 있습니다:\n---\ntitle: Test Article\ndate: 2024/9/20\ndescription: It is a test article.\ntag: test\nauthor: You\n---\nIt is a test article.\nIt is only for test purpose.","5-2-포스트-빌드-및-배포#5-2. 포스트 빌드 및 배포":"Markdown 파일을 추가한 후, 다시 블로그를 빌드하고 배포합니다:\nnpm run build\nnpm run deploy\n이제 새로운 포스트가 블로그에 추가된 것을 확인할 수 있습니다.","6-사이트맵#6. 사이트맵":"npm run build 수행 시마다 정적 사이트맵 파일(sitemap.xml)을 갱신 및 생성하게 하는 방법입니다.","6-1-next-sitemap--패키지-설치#6-1. next-sitemap  패키지 설치":"npm install next-sitemap","6-2-next-sitemapconfigjs-설정#6-2. next-sitemap.config.js 설정":"프로젝트 루트에 next-sitemap.config.js 파일을 다음과 같이 생성합니다:\n/** @type {import('next-sitemap').IConfig} */\nmodule.exports = {\n  siteUrl: process.env.SITE_URL || 'https://<your-github-username>.github.io',\n  generateRobotsTxt: true,\n  generateIndexSitemap: false,\n}","6-3-packagejson-수정#6-3. package.json 수정":"package.json 파일에 사이트맵 생성을 위한 스크립트를 추가합니다. scripts 섹션에  postbuild를 아래처럼 추가하세요:\n{\n  \"scripts\": {\n    // ... 전략 ...\n    \"postbuild\": \"next-sitemap\",\n    // ... 후략 ...\n  }\n}","결론#결론":"Next.js Blog Boilerplate를 사용해 GitHub Pages에 블로그를 배포하는 방법을 알아보았습니다. Boilerplate의 적용, GitHub 리포지토리 생성 및 Git 설정, Next.js 설정, Markdown 포스트 작성, 사이트맵 생성에 이르는 방법을 Step-by-Step 설명하여, 순서대로 따라하면 손쉽게 정적 블로그를 만들어 낼 수 있음을 알 수 있습니다."}},"/":{"title":"About","data":{"":"Hey, I'm a Senior Software Engineer at Company. I enjoy working with Next.js and crafting beautiful front-end experiences.This portfolio is built with Next.js and a library called Nextra. It allows you to write Markdown and focus on the content of your portfolio.Deploy your own in a few minutes.\nTwitter @yourname\nGitHub @yourname\nInstagram @yourname\nEmail your@name.com"}},"/posts/markdown":{"title":"Markdown Examples","data":{"h2-heading#h2 Heading":"","h3-heading#h3 Heading":"","h4-heading#h4 Heading":"","h5-heading#h5 Heading":"","h6-heading#h6 Heading":"","emphasis#Emphasis":"This is bold textThis is italic textStrikethrough","blockquotes#Blockquotes":"Develop. Preview. Ship. – Vercel","lists#Lists":"Unordered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nOrdered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa","code#Code":"Inline code\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}","tables#Tables":"Option\tDescription\tFirst\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tSecond\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tThird\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","links#Links":"Next.js\nNextra\nVercel","footnotes#Footnotes":"Footnote .\nFootnote .\nFootnote can have markupand multiple paragraphs.Footnote text."}},"/posts/test":{"title":"Test Article","data":{"":"It is a test article.\nIt is only for test purpose."}},"/posts":{"title":"Posts","data":{}},"/photos":{"title":"Photos","data":{"":"Here's some of my photography.\nUnsplash ↗ \nUnsplash ↗"}},"/posts/pages":{"title":"Next.js Pages","data":{"":"In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\nfunction About() {\n  return <div>About</div>\n}\nexport default About","pages-with-dynamic-routes#Pages with Dynamic Routes":"Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.","pre-rendering#Pre-rendering":"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)","two-forms-of-pre-rendering#Two forms of Pre-rendering":"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use Client-side Rendering along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the Data Fetching documentation.","static-generation-recommended#Static Generation (Recommended)":"If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pages with or without data. Let's take a look at each case.","static-generation-without-data#Static Generation without data":"By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\nfunction About() {\n  return <div>About</div>\n}\nexport default About\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.","static-generation-with-data#Static Generation with data":"Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).","scenario-1-your-page-content-depends-on-external-data#Scenario 1: Your page content depends on external data":"Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nexport default Blog\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.\nfunction Blog({ posts }) {\n  // Render posts...\n}\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\nexport default Blog\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","scenario-2-your-page-paths-depend-on-external-data#Scenario 2: Your page paths depend on external data":"Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\nHowever, which id you want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.So your page paths that are pre-rendered depend on external data**.** To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:\nfunction Post({ post }) {\n  // Render post...\n}\nexport async function getStaticPaths() {\n  // ...\n}\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n  // Pass post data to the page via props\n  return { props: { post } }\n}\nexport default Post\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation.","when-should-i-use-static-generation#When should I use Static Generation?":"We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:\nMarketing pages\nBlog posts\nE-commerce product listings\nHelp and documentation\nYou should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:\nUse Static Generation with Client-side Rendering: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.\nUse Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.","server-side-rendering#Server-side Rendering":"Also referred to as \"SSR\" or \"Dynamic Rendering\".\nIf a page uses Server-side Rendering, the page HTML is generated on each request.To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:\nfunction Page({ data }) {\n  // Render data...\n}\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\nexport default Page\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.To learn more about how getServerSideProps works, check out our Data Fetching documentation","summary#Summary":"We've discussed two forms of pre-rendering for Next.js.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request. To make a page use Static Generation, either export the page component, or export getStaticProps (and getStaticPaths if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\nServer-side Rendering: The HTML is generated on each request. To make a page use Server-side Rendering, export getServerSideProps. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary."}},"/tags/[tag]":{"title":"Tagged Posts","data":{}}}